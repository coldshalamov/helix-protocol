"""Minimal Flask dashboard exposing Helix chain information.

This module provides a JSON API used by the future explorer UI. It reads
on-disk data generated by the Helix node such as the blockchain file,
statement/event JSON files and the peer discovery map.

The following endpoints are available::

    GET /chain          -> full blockchain state
    GET /statement/<id> -> event/statement details
    GET /peers          -> known peer map

The data directory can be configured via the ``HELIX_DATA_DIR`` environment
variable. By default ``data/`` in the repository root is used.
"""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any, Dict, List

from flask import Flask, jsonify, abort

try:
    from helix.blockchain import load_chain
except Exception:  # pragma: no cover - optional import fallback
    from blockchain import load_chain  # type: ignore


DATA_DIR = Path(os.getenv("HELIX_DATA_DIR", "data"))
CHAIN_FILES = ["blockchain.jsonl", "chain.json", "chain.jsonl"]
EVENTS_DIR = DATA_DIR / "events"
PEERS_FILE = DATA_DIR / "peers.json"

app = Flask(__name__)


def _read_chain() -> List[Dict[str, Any]]:
    """Load the blockchain from disk."""
    for name in CHAIN_FILES:
        path = DATA_DIR / name
        if path.exists():
            try:
                return load_chain(str(path))
            except Exception:
                continue
    return []


def _load_event(event_id: str) -> Dict[str, Any] | None:
    path = EVENTS_DIR / f"{event_id}.json"
    if not path.exists():
        return None
    try:
        with open(path, "r", encoding="utf-8") as fh:
            return json.load(fh)
    except Exception:
        return None


def _load_peers() -> List[Dict[str, Any]]:
    if not PEERS_FILE.exists():
        return []
    try:
        with open(PEERS_FILE, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        if isinstance(data, list):
            return data
    except Exception:
        pass
    return []


@app.get("/chain")
def chain_state() -> Any:
    """Return the full blockchain state as JSON."""
    chain = _read_chain()
    return jsonify({"chain": chain})


@app.get("/statement/<string:event_id>")
def statement_lookup(event_id: str) -> Any:
    """Return statement/event information for ``event_id``."""
    event = _load_event(event_id)
    if event is None:
        abort(404)
    return jsonify(event)


@app.get("/peers")
def peer_map() -> Any:
    """Return the known peer map."""
    peers = _load_peers()
    return jsonify({"peers": peers})


if __name__ == "__main__":  # pragma: no cover - manual execution
    app.run(debug=True)
